<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Front-Office Next</title>
  <script type="module" src="index.js"></script>
  <link rel="stylesheet" type="text/css" href="index.scss">
  <link rel="stylesheet" type="text/css" href="assets/github.css">
</head>
<body>
  <main class="slides">
    <section id="title">
      <h1>KURATOR<br>Front-Office Next</h1>
      <footer class="notes">
        <p class="note">Hi!</p>
      </footer>
    </section>

    <section id="kurator">
      <figure>
        <img src="assets/images/back-office.jpg">
        <figcaption>Back-Office</figcaption>
      </figure>
      <figure>
        <img src="assets/images/front-office.jpg">
        <figcaption>Front-Office</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">We are very fond of cute code names here at NRK</p>
        <p class="note">This is Kurator. It has two components: Back-Office is the application Journalists use to edit content, and Front-Office is the application that renders that content for the web</p>
      </footer>
    </section>

    <section id="front-office">
      <figure>
        <img src="assets/images/front-office-full.jpg">
        <span class="highlight-house"><span>house</span></span>
        <span class="highlight-floor"><span>floor</span></span>
        <span class="highlight-room"><span>room</span></span>
        <span class="highlight-newsfeed"><span>guestroom - newsfeed</span></span>
      </figure>
      <footer class="notes">
        <p class="note">Front-Office is further divided into multiple parts</p>
        <p class="note">This is a house</p>
        <p class="note">This is a floor in that house</p>
        <p class="note">This is a room in that floor</p>
        <p class="note">And this is a guestroom called newsfeed</p>
      </footer>
    </section>

    <section id="front-office-next">
      <figure>
        <img src="assets/images/front-office-full.jpg">
        <figcaption>Previous</figcaption>
      </figure>
      <figure>
        <img src="assets/images/front-office-full.jpg">
        <figcaption>Next</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">Last summer I asked Kristoffer, who was tech lead for Kurator at the time, if we could rewrite Front-Office. He said yes, as long as it looked exactly like the existing version</p>
        <p class="note">Six months later, we have two versions of Front-Office: Previous and Next</p>
      </footer>
    </section>

    <section id="pixel">
      <figure>
        <div class="pixel previous"></div>
        <figcaption>Previous</figcaption>
      </figure>
      <figure>
        <div class="pixel next"></div>
        <figcaption>Next</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">If we compare a pixel from Previous and one from Next, they look the same</p>
        <p class="note">But if a user gets that pixel sooner, are they really the same?</p>
        <p class="note">And if a user wants a blue version of that pixel...</p>
        <p class="note">...or purple...</p>
        <p class="note">...or green...</p>
        <p class="note">...then they really aren't the same at all</p>
      </footer>
    </section>

    <section id="feature">
      <h1>Performance is a <em>feature</em></h1>
      <footer class="notes">
        <p class="note">This was the real motivation for the rewrite: improve render performance in order to be able to offer customized content</p>
        <p class="note">Performance is hard to observe directly, but it can enable other more visible features, and we wanted to open up for delivering personalised content on nrk.no</p>
      </footer>
    </section>

    <section id="motivation">
      <h1>"reducing complexity is the most important element of software design"</h1>
      <footer class="notes">
        <p class="note">My real motivation, however, was to design a system that was simpler</p>
      </footer>
    </section>

    <section id="book">
      <img src="assets/images/book.jpg">
      <ul>
        <li class="one">"the greatest limitation in writing software is our ability to understand the systems we are creating"</li>
        <li class="two">"developers [...] should always be on the lookout for opportunities to improve the design of the system"</li>
        <li class="three">"developers should always be thinking about complexity"</li>
      </ul>
      <footer class="notes">
        <p class="note">This book by John Ousterhout is fantastic, and basically deals with high level techniques for reducing complexity in software systems</p>
        <p class="note">quote</p>
        <p class="note">quote</p>
        <p class="note">quote</p>
      </footer>
    </section>

    <section id="config">
      <h1>#1 Configuration</h1>
      <pre class="code config-json"><code class="json">
        {
          "api": {
            "cacheMaxSize": 1000,
            "maxAgeFeed": "1m",
            "maxAgeImmutable": "24h",
            "maxAgeMutable": "1s",
            "origin": "${__SUPPLIED_BY_ENV__}",
            "pathnames": {
              "blueprint": "/houses/${id}/ids",
              "house": "/houses/${itemId}/${id}",
              "feed": "/${type}/houses/${houseId}",
              "floor": "/floors/${itemId}/${id}",
              "room": "/rooms/${itemId}/${id}"
            },
            "retry": "${__SUPPLIED_BY_ENV__}",
            "secretKey": "${API_SECRET}",
            "timeout": "${__SUPPLIED_BY_ENV__}",
            "urls": "**generated at runtime**"
          }
        }
      </code></pre>
      <pre class="code config-dir"><code class="txt">
        /config
          **files here are added by runtime env**.txt
          **files here are loaded in sort order**.txt
          local.json
      </code></pre>
      <pre class="code config-js"><code class="js">
        import config from '@nrk/frontend-common/config.js';

        const houseEndpoint = config.get('api.urls.house');
        // => https://kurator-api-stage.nrk.no/houses/${itemId}/${id}
        const apartmentEndpoint = config.get('api.urls.apartment');
        // => Boom! Error: no config value found for "api.urls.apartment"
      </code></pre>
      <pre class="code config-node-env"><code class="json">
        {
          "NODE_ENV": {
            "test": {
              "api": {
                "origin": "http://localhost:8080"
              }
            },
            "production": {
              "api": {
                "origin": "https://kurator-api.nrk.no"
              }
            }
          }
        }
      </code></pre>
      <footer class="notes">
        <p class="note">One of the most important goals of good design is for a system to be obvious</p>
        <p class="note">One place where being obvious is important is application configuration</p>
        <p class="note">Our new config setup describes all configuration options in one place (config.json), and is explicit about which values must be supplied by the runtime environment</p>
        <p class="note">Environment values are loaded from the /config directory, which can be populated using Kubernetes ConfigMaps</p>
        <p class="note">During runtime, any missing environment variables will throw and cause the application to crash, preventing rollout</p>
        <p class="note">Reading non-existant values will also throw an error. Obvious errors are simpler to fix than hidden ones</p>
        <p class="note">Another benefit of being explicit is that the application has no concept of environment, only configuration, which is also much simpler</p>
      </footer>
    </section>

    <section id="dev-env">
      <h1>#2 Development Environment</h1>
      <figure>
        terminal video
        <figcaption>Previous</figcaption>
      </figure>
      <figure>
        terminal video
        <figcaption>Next</figcaption>
      </figure>
      <pre class="code entry"><code class="js">
        require = require('esm')(module, { mainFields: ['module', 'main'] });
        module.exports = require('./src/server/index.js').default();
      </code></pre>
      <pre class="code mock"><code class="bash">
        kurator-front-office-next $ npm run dev:mock

        > kurator-front-office-next@1.0.0 dev /Users/alex/PROJECTS/NRK/kurator-front-office-next
        > dvlp --transpiler ./scripts/transpile.js --mock ./mock ./index-dev.js

          âœ” loaded transpiler from scripts/transpile.js
          âœ” loaded 1 mock response from mock/bottom-menu.mock.json
          âœ” loaded 5 mock responses from mock/elglobo.mock.json
          âœ” loaded 4 mock responses from mock/floor-29-26.mock.json
          âœ” loaded 2 mock responses from mock/guestroom-133-7.mock.json
          âœ” loaded 127 mock responses from mock/house-12.mock.json
          âœ” loaded 136 mock responses from mock/house-2-900.mock.json
          âœ” loaded 45 mock responses from mock/house-5.mock.json
          âœ” loaded 144 mock responses from mock/house-uu.mock.json
          âœ” loaded 2 mock responses from mock/newsfeed.mock.json
          âœ” loaded 2 mock responses from mock/rss.mock.json
          âœ” loaded 1 mock response from mock/videoroom-289-288.mock.json

          ðŸ’¥ serving ./index-dev.js at http://localhost:3000
          ðŸ‘€ watching for changes...
      </code></pre>
      <pre class="code test"><code class="js">
        const api = await testServer({ autorespond: false, latency: 0, 8080 });
        api.mocks.add('http://localhost:8080/houses/2/ids', {
          error: true,
          body: {}
        });
        const app = await application();
        const res = await app.inject({
          method: 'GET',
          url: 'http://localhost:3000'
        });
        expect(res.statusCode).to.equal(500);
      </code></pre>
      <footer class="notes">
        <p class="note">Probably the biggest differnce between Previous and Next is the development environment</p>
        <p class="note">Previous used Nodemon to restart the application server, Babel to transpile server code, and Webpack to compile assets for the browser</p>
        <p class="note">This type of tooling chain is complex to set up, slow to restart after changes, and requires special server middleware to be used, forcing the application to be aware of it's environment</p>
        <p class="note">Next uses dvlp to restart the application server, esm to enable es modules for server code, and no asset compiler (except Sass)</p>
        <p class="note">Most importantly, however, is that the application itself is totally unaware it's running in development. There is no difference between development and production code beyond configuration</p>
        <p class="note">With dvlp we also get easy mocking during runtime and testing</p>
      </footer>
    </section>

    <section id="modules">
      <h1>#3 ES Modules</h1>
      <img src="assets/images/waterfall.jpg">
      <pre class="code load"><code class="html">
        &lt;head&gt;
          &lt;link rel=&quot;preload&quot; href=&quot;index.mjs&quot; as=&quot;script&quot;&gt;
          &lt;script&gt;
            window.cutsTheMustard = testDOMProp('visibilityState', document);
            if (window.Reflect == null) {
              loadScript('es6-polyfill.js', { async: false, defer: false });
            }
            if (!('customElements' in window)) {
              loadScript('dom-polyfill.js', { async: false, defer: false });
            }
          &lt;/script&gt;
          &lt;script&gt;
            loadScript('index.mjs', { async: false, defer: false, module: true });
          &lt;/script&gt;
          &lt;script nomodule&gt;
            loadScript(window.cutsTheMustard ? 'index.js' : 'index-legacy.js',
              { async: false, defer: false }
            );
          &lt;/script&gt;
        &lt;/head&gt;
      </code></pre>
      <footer class="notes">
        <p class="note">The most important development principle is that Next treats bundling as a production optimization, like minification</p>
        <p class="note">During development, js files are loaded by the browser via standard es module import syntax</p>
        <p class="note">We write idiomatic JavaScript, and dvlp handles resolving bare imports behind the scenes</p>
        <p class="note">In production, server and client code is bundled with Rollup.js</p>
        <p class="note">Client code is bundled twice to allow for serving different code to different browsers</p>
        <p class="note">This so-called differential bundling allows newer browsers to load untranspiled es6 code (async/await, classes, etc), and older browsers transpiled es5 code</p>
      </footer>
    </section>

    <section id="templates">
      <h1>#4 Tagged Template Literals</h1>
      <pre class="code layout"><code class="js">
        import Head from &apos;./head.js&apos;;
        import House from &apos;./house.js&apos;;
        import { html } from &apos;@popeindustries/lit-html-server&apos;;

        /**
         * Layout template
         * @param {object} data
         * @param {RenderContext} context
         * @returns {TemplateResult}
         */
        function layout(data, context) {
          return html`
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;nb-NO&quot;&gt;
              ${Head(data, context)}
              &lt;body class=&quot;kur-house&quot;&gt;
                ${House(data, context)}
              &lt;/body&gt;
            &lt;/html&gt;
          `;
        }
      </code></pre>
      <pre class="code component"><code class="js">
        import Floor from &apos;./floor.js&apos;;
        import { getHouse } from &apos;./api-agent.js&apos;;
        import { html } from &apos;@popeindustries/lit-html-server&apos;;

        /**
         * House component
         * @param {object} data
         * @param {RenderContext} context
         * @returns {Promise&lt;TemplateResult|undefined&gt;}
         */
        export default async function House(data, context) {
          const { floors } = await getHouse(data.houseId);

          return html`
            &lt;main&gt;
              ${floors.map((floor) =&gt; Floor(floor, context))}
            &lt;/main&gt;
          `;
        }
      </code></pre>
      <footer class="notes">
        <p class="note">For rendering markup, Next uses lit-html's template literal syntax (instead of React)</p>
        <p class="note">Template literals are a native JavaScript syntax for performing custom string interpolation</p>
        <p class="note">lit-html adds some sugar for handling attributes, and various helper functions called directives</p>
      </footer>
    </section>

    <section id="streaming">
      <h1>#5 Streaming Renderer</h1>
      <pre class="code pipe"><code class="js">
        import { createServer } from &apos;http&apos;;
        import { renderToStream } from &apos;@popeindustries/lit-html-server&apos;;
        import template from './template.js';

        createServer((req, res) => {
          res.writeHead(200);
          renderToStream(template()).pipe(res);
        }).listen(3000);
      </code></pre>
      <img src="assets/images/server-timing.jpg">
      <pre class="code buffer"><code class="js">
        import { handleError } from &apos;./error.js&apos;;
        import { renderToStream, renderToString } from &apos;@popeindustries/lit-html-server&apos;;
        import template from &apos;./template.js&apos;;

        app.get(&apos;/&apos;, async (request, reply) => {
          let markup;
          try {
            if (request.isBot) {
              markup = await renderToString(template());
            } else {
              markup = renderToStream(template());
              markup.on(&apos;error&apos;, handleError);
            }
          } catch (err) {
            return handleError(err);
          }

          reply.type(&apos;text/html&apos;).code(200).send(markup);
        })
      </code></pre>
      <footer class="notes">
        <p class="note"></p>
        <p class="note"></p>
        <p class="note"></p>
      </footer>
    </section>

    <section id="cache">
      <h1>#6 Caching</h1>
      <footer class="notes">
        <p class="note"></p>
      </footer>
    </section>

    <section id="custom-elements">
      <h1>#7 Custom Elements</h1>
      <footer class="notes">
        <p class="note"></p>
      </footer>
    </section>

    <section id="sse">
      <h1>#8 EventSource</h1>
      <footer class="notes">
        <p class="note"></p>
      </footer>
    </section>

    <section id="embed">
      <h1>#9 Core-Embed</h1>
      <footer class="notes">
        <p class="note"></p>
      </footer>
    </section>
  </main>
  <div class="clock"></div>
</body>
</html>
