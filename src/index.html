<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Front-Office Next</title>
  <script type="module" src="index.js"></script>
  <link rel="stylesheet" type="text/css" href="index.scss">
  <link rel="stylesheet" type="text/css" href="assets/github.css">
</head>
<body>
  <main class="slides">
    <section id="title">
      <h1>KURATOR<br>Front-Office Next</h1>
      <footer class="notes">
        <p class="note">Hi!</p>
      </footer>
    </section>

    <section id="kurator">
      <figure>
        <img src="assets/images/back-office.jpg">
        <figcaption>Back-Office</figcaption>
      </figure>
      <figure>
        <img src="assets/images/front-office.jpg">
        <figcaption>Front-Office</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">We are very fond of cute code names here at NRK</p>
        <p class="note step">This is Kurator. It has two components: Back-Office is the application Journalists use to edit content, and Front-Office is the application that renders that content for the web</p>
      </footer>
    </section>

    <section id="front-office">
      <figure>
        <img src="assets/images/front-office-full.jpg">
        <span class="highlight highlight-house"><span>house</span></span>
        <span class="highlight highlight-floor"><span>floor</span></span>
        <span class="highlight highlight-room"><span>room</span></span>
        <span class="highlight highlight-newsfeed"><span>guestroom (newsfeed)</span></span>
      </figure>
      <footer class="notes">
        <p class="note">Front-Office is further divided into multiple parts</p>
        <p class="note step">This is a house</p>
        <p class="note step">This is a floor in that house</p>
        <p class="note step">This is a room in that floor</p>
        <p class="note step">And this is a guestroom called newsfeed</p>
      </footer>
    </section>

    <section id="front-office-next">
      <figure class="next">
        <img src="assets/images/front-office-full.jpg">
        <figcaption>Next</figcaption>
      </figure>
      <figure class="prev">
        <img src="assets/images/front-office-full.jpg">
        <figcaption>Previous</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">Last summer I asked Kristoffer, who was tech lead for Kurator at the time, if we could rewrite Front-Office. He said yes, as long as it looked exactly like the existing version</p>
        <p class="note step">Six months later, we have two versions of Front-Office: Previous and Next</p>
      </footer>
    </section>

    <section id="pixel">
      <figure>
        <div class="pixel prev"></div>
        <figcaption>Previous</figcaption>
      </figure>
      <figure>
        <div class="pixel next"></div>
        <figcaption>Next</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">If we compare a pixel from Previous and one from Next, they look the same</p>
        <p class="note step">But if a user gets that pixel sooner, are they really the same?</p>
        <p class="note step">And if a user wants a blue version of that pixel...</p>
        <p class="note step">...or purple...</p>
        <p class="note step">...or green...</p>
        <p class="note">...then they really aren't the same at all</p>
      </footer>
    </section>

    <section id="feature">
      <h1>Performance is a <em>feature</em></h1>
      <footer class="notes">
        <p class="note">This was the real motivation for the rewrite: improve render performance in order to be able to offer customized content</p>
        <p class="note">Performance is hard to observe directly, but it can enable other more visible features, and we wanted to open up for delivering personalised content on nrk.no</p>
      </footer>
    </section>

    <section id="motivation">
      <h1>"reducing complexity is the most important element of software design"</h1>
      <footer class="notes">
        <p class="note">My real motivation, however, was to design a system that was simpler</p>
      </footer>
    </section>

    <section id="book">
      <img src="assets/images/book.jpg">
      <ul>
        <li class="one">"the greatest limitation in writing software is our ability to understand the systems we are creating"</li>
        <li class="two">"developers [...] should always be on the lookout for opportunities to improve the design of the system"</li>
        <li class="three">"developers should always be thinking about complexity"</li>
      </ul>
      <footer class="notes">
        <p class="note">This book by John Ousterhout is fantastic, and basically deals with high level techniques for reducing complexity in software systems</p>
        <p class="note">quote</p>
        <p class="note">quote</p>
        <p class="note">quote</p>
      </footer>
    </section>

    <section id="config">
      <h1>#1 Configuration</h1>
      <pre class="code config-json"><code class="json">
        {
          "api": {
            "cacheMaxSize": 1000,
            "maxAgeFeed": "1m",
            "maxAgeImmutable": "24h",
            "maxAgeMutable": "1s",
            "origin": "${__SUPPLIED_BY_ENV__}",
            "pathnames": {
              "blueprint": "/houses/${id}/ids",
              "house": "/houses/${itemId}/${id}",
              "feed": "/${type}/houses/${houseId}",
              "floor": "/floors/${itemId}/${id}",
              "room": "/rooms/${itemId}/${id}"
            },
            "retry": "${__SUPPLIED_BY_ENV__}",
            "secretKey": "${API_SECRET}",
            "timeout": "${__SUPPLIED_BY_ENV__}",
            "urls": "**generated at runtime**"
          }
        }
      </code></pre>
      <pre class="code config-dir"><code class="txt">
        /config
          **files here are added by runtime env**.txt
          **files here are loaded in sort order**.txt
          local.json
      </code></pre>
      <pre class="code config-js"><code class="js">
        import config from '@nrk/frontend-common/config.js';

        const houseEndpoint = config.get('api.urls.house');
        // => https://kurator-api-stage.nrk.no/houses/${itemId}/${id}
        const apartmentEndpoint = config.get('api.urls.apartment');
        // => Boom! Error: no config value found for "api.urls.apartment"
      </code></pre>
      <pre class="code config-node-env"><code class="json">
        {
          "NODE_ENV": {
            "test": {
              "api": {
                "origin": "http://localhost:8080"
              }
            },
            "production": {
              "api": {
                "origin": "https://kurator-api.nrk.no"
              }
            }
          }
        }
      </code></pre>
      <footer class="notes">
        <p class="note">One of the most important goals of good design is for a system to be obvious</p>
        <p class="note">One place where being obvious is important is application configuration</p>
        <p class="note">Our new config setup describes all configuration options in one place (config.json), and is explicit about which values must be supplied by the runtime environment</p>
        <p class="note">Environment values are loaded from the /config directory, which can be populated using Kubernetes ConfigMaps</p>
        <p class="note">During runtime, any missing environment variables will throw and cause the application to crash, preventing rollout</p>
        <p class="note">Reading non-existant values will also throw an error. Obvious errors are simpler to fix than hidden ones</p>
        <p class="note">Another benefit of being explicit is that the application has no concept of environment, only configuration, which is also much simpler</p>
      </footer>
    </section>

    <section id="dev-env">
      <h1>#2 Development Environment</h1>
      <figure>
        terminal video
        <figcaption>Previous</figcaption>
      </figure>
      <figure>
        terminal video
        <figcaption>Next</figcaption>
      </figure>
      <pre class="code entry"><code class="js">
        require = require('esm')(module, { mainFields: ['module', 'main'] });
        module.exports = require('./src/server/index.js').default();
      </code></pre>
      <pre class="code mock"><code class="bash">
        kurator-front-office-next $ npm run dev:mock

        > kurator-front-office-next@1.0.0 dev /Users/alex/PROJECTS/NRK/kurator-front-office-next
        > dvlp --transpiler ./scripts/transpile.js --mock ./mock ./index-dev.js

          âœ” loaded transpiler from scripts/transpile.js
          âœ” loaded 1 mock response from mock/bottom-menu.mock.json
          âœ” loaded 5 mock responses from mock/elglobo.mock.json
          âœ” loaded 4 mock responses from mock/floor-29-26.mock.json
          âœ” loaded 2 mock responses from mock/guestroom-133-7.mock.json
          âœ” loaded 127 mock responses from mock/house-12.mock.json
          âœ” loaded 136 mock responses from mock/house-2-900.mock.json
          âœ” loaded 45 mock responses from mock/house-5.mock.json
          âœ” loaded 144 mock responses from mock/house-uu.mock.json
          âœ” loaded 2 mock responses from mock/newsfeed.mock.json
          âœ” loaded 2 mock responses from mock/rss.mock.json
          âœ” loaded 1 mock response from mock/videoroom-289-288.mock.json

          ðŸ’¥ serving ./index-dev.js at http://localhost:3000
          ðŸ‘€ watching for changes...
      </code></pre>
      <pre class="code test"><code class="js">
        const api = await testServer({ autorespond: false, latency: 0, 8080 });
        api.mocks.add('http://localhost:8080/houses/2/ids', {
          error: true,
          body: {}
        });
        const app = await application();
        const res = await app.inject({
          method: 'GET',
          url: 'http://localhost:3000'
        });
        expect(res.statusCode).to.equal(500);
      </code></pre>
      <footer class="notes">
        <p class="note">Probably the biggest differnce between Previous and Next is the development environment</p>
        <p class="note">Previous used Nodemon to restart the application server, Babel to transpile server code, and Webpack to compile assets for the browser</p>
        <p class="note">This type of tooling chain is complex to set up, slow to restart after changes, and requires special server middleware to be used, forcing the application to be aware of it's environment</p>
        <p class="note">Next uses dvlp to restart the application server, esm to enable es modules for server code, and no asset compiler (except Sass)</p>
        <p class="note">Most importantly, however, is that the application itself is totally unaware it's running in development. There is no difference between development and production code beyond configuration</p>
        <p class="note">With dvlp we also get easy mocking during runtime and testing</p>
      </footer>
    </section>

    <section id="modules">
      <h1>#3 ES Modules</h1>
      <img src="assets/images/waterfall.jpg">
      <pre class="code load"><code class="html">
        &lt;head&gt;
          &lt;link rel=&quot;preload&quot; href=&quot;index.mjs&quot; as=&quot;script&quot;&gt;
          &lt;script&gt;
            window.cutsTheMustard = testDOMProp('visibilityState', document);
            if (window.Reflect == null) {
              loadScript('es6-polyfill.js', { async: false, defer: false });
            }
            if (!('customElements' in window)) {
              loadScript('dom-polyfill.js', { async: false, defer: false });
            }
          &lt;/script&gt;
          &lt;script&gt;
            loadScript('index.mjs', { async: false, defer: false, module: true });
          &lt;/script&gt;
          &lt;script nomodule&gt;
            loadScript(window.cutsTheMustard ? 'index.js' : 'index-legacy.js',
              { async: false, defer: false }
            );
          &lt;/script&gt;
        &lt;/head&gt;
      </code></pre>
      <footer class="notes">
        <p class="note">The most important development principle is that Next treats bundling as a production optimization, like minification</p>
        <p class="note">During development, js files are loaded by the browser via standard es module import syntax</p>
        <p class="note">We write idiomatic JavaScript, and dvlp handles resolving bare imports behind the scenes</p>
        <p class="note">In production, server and client code is bundled with Rollup.js</p>
        <p class="note">Client code is bundled twice to allow for serving different code to different browsers</p>
        <p class="note">This so-called differential bundling allows newer browsers to load untranspiled es6 code (async/await, classes, etc), and older browsers transpiled es5 code</p>
      </footer>
    </section>

    <section id="templates">
      <h1>#4 Tagged Template Literals</h1>
      <pre class="code layout"><code class="js">
        import Head from &apos;./head.js&apos;;
        import House from &apos;./house.js&apos;;
        import { html } from &apos;@popeindustries/lit-html-server&apos;;

        /**
         * Layout template
         * @param {object} data
         * @param {RenderContext} context
         * @returns {TemplateResult}
         */
        function layout(data, context) {
          return html`
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;nb-NO&quot;&gt;
              ${Head(data, context)}
              &lt;body class=&quot;kur-house&quot;&gt;
                ${House(data, context)}
              &lt;/body&gt;
            &lt;/html&gt;
          `;
        }
      </code></pre>
      <pre class="code component"><code class="js">
        import Floor from &apos;./floor.js&apos;;
        import { getHouse } from &apos;./api-agent.js&apos;;
        import { html } from &apos;@popeindustries/lit-html-server&apos;;

        /**
         * House component
         * @param {object} data
         * @param {string} data.houseId
         * @param {RenderContext} context
         * @returns {Promise&lt;TemplateResult|undefined&gt;}
         */
        export default async function House(data, context) {
          const { floors } = await getHouse(data.houseId);

          return html`
            &lt;main&gt;
              ${floors.map((floor) =&gt; Floor(floor, context))}
            &lt;/main&gt;
          `;
        }
      </code></pre>
      <footer class="notes">
        <p class="note">For rendering markup, Next uses lit-html's template literal syntax (instead of React)</p>
        <p class="note">Template literals are a native JavaScript syntax for performing custom string interpolation</p>
        <p class="note">lit-html adds some sugar for handling attributes, and various helper functions called directives</p>
        <p class="note">Note that the House component is an async function, and returns a Promise</p>
        <p class="note">The tag function can return anything, not just a string</p>
      </footer>
    </section>

    <section id="streaming">
      <h1>#5 Streaming Renderer</h1>
      <pre class="code pipe"><code class="js">
        import { createServer } from &apos;http&apos;;
        import { renderToStream } from &apos;@popeindustries/lit-html-server&apos;;
        import template from './template.js';

        createServer((req, res) => {
          res.writeHead(200);
          renderToStream(template()).pipe(res);
        }).listen(3000);
      </code></pre>
      <img src="assets/images/server-timing.jpg">
      <pre class="code error"><code class="js">
        /**
         * Floor component
         * @param {object} data
         * @param {string} data.itemId
         * @param {string} data.id
         * @param {RenderContext} context
         * @returns {Promise&lt;TemplateResult|undefined&gt;}
         */
        export default async function Floor(data, context) {
          const floorData = await getFloor(data.itemId, data.id);

          if (floorData.error) {
            if (!context.isStreaming) {
              throw floorData.error;
            } else {
              // Fallback to empty floor
              return html`
                &lt;section class=&quot;kur-floor&quot;&gt;&lt;/section&gt;
              `;
            }
          }
        }
      </code></pre>
      <pre class="code buffer"><code class="js">
        import { handleError } from &apos;./error.js&apos;;
        import { renderToStream, renderToString } from &apos;@popeindustries/lit-html-server&apos;;
        import template from &apos;./template.js&apos;;

        app.get(&apos;/&apos;, async (request, reply) => {
          let markup;
          try {
            if (request.isBot) {
              markup = await renderToString(template());
            } else {
              markup = renderToStream(template());
              markup.on(&apos;error&apos;, handleError);
            }
          } catch (err) {
            return handleError(err);
          }

          reply.type(&apos;text/html&apos;).code(200).send(markup);
        })
      </code></pre>
      <footer class="notes">
        <p class="note">A streaming template renderer is capable of rendering the data structure returned by a tagged template literal as a Node.js ReadableStream, and push data to the response stream as async template data is resolved</p>
        <p class="note">This enables us to "flush early, flush often", even before we begin fetching api data</p>
        <p class="note">This streaming approach simplifies request handling by allowing us to get the response out the door as fast as possible</p>
        <p class="note">The only weakness with this approach is that you won't be able to change the response status code if an error occurs during async rendering</p>
        <p class="note">In cases where status codes are important (search engines, health checks, liveness probes, etc), we check the user-agent against a list of known non-human agents and buffer instead</p>
      </footer>
    </section>

    <section id="cache">
      <h1>#6 Caching</h1>
      <pre class="code agent"><code class="js">
        import { Cache } from &apos;@nrk/frontend-common/cache.js&apos;;
        import config from &apos;@nrk/frontend-common/config.js&apos;;
        import { staleWhileRevalidate } from &apos;@nrk/frontend-common/cache-strategies.js&apos;;
        import { template } from &apos;@nrk/frontend-common/string.js&apos;;

        const cache = new Cache();
        const apiConfig = config.get(&apos;api&apos;);

        async function getFloor(itemId, id, context) {
          const url = template(apiConfig.urls.floor, { itemId, id });
          try {
            return await staleWhileRevalidate(url, {
              defaultMaxAge: apiConfig.maxAgeImmutable,
              requestOptions: {
                retry: apiConfig.retry,
                timeout: apiConfig.timeout
              }
            }).body;
          } catch (error) {
            return { id, itemId, error };
          }
        }
      </code></pre>
      <footer class="notes">
        <p class="note">Streaming in this way is possible because we have pushed data fetching responsibility down the render tree, and this is only possible due to our fetching and caching infrastructure</p>
        <p class="note">Built around a port of the Browser's Cache api, data fetching is implemented via one of three cache strategies: network-first, stale-while-revalidate, or network-only</p>
        <p class="note">Includes retry, timeout, backoff, LRU, and request collapsing</p>
        <p class="note">Could be better: adaptive fetch control</p>
      </footer>
    </section>

    <section id="custom-elements">
      <h1>#7 Custom Elements</h1>
      <pre class="code markup"><code class="html">
        &lt;kur-newsfeed url=&quot;https://kurator-ssehub.nrk.no&quot;&gt;&lt;/kur-newsfeed&gt;
      </code></pre>
      <pre class="code updatable"><code class="js">
        import UpdatableElement from '../../utils/updatable-element.js';

        class KurNewsfeed extends UpdatableElement {
          static get properties() {
            //...
          }
          initialise() {
            //...
          }
          render() {
            //...
          }
        }

        if (!window.customElements.get('kur-newsfeed')) {
          window.customElements.define('kur-newsfeed', KurNewsfeed);
        }
      </code></pre>
      <footer class="notes">
        <p class="note">Next is largely a static page, but for the components that are interactive, we use Custom Elements to encapsulate client logic</p>
        <p class="note">We created an element base class loosely based on lit-element</p>
        <p class="note">The most importand feature of Custom Elements for Next is that components are self registering, and code can run as soon as possible before markup is rendered</p>
      </footer>
    </section>

    <section id="sse">
      <h1>#8 EventSource</h1>
      <img src="assets/images/newsfeed.jpg">
      <pre class="code"><code class="js">
        initEventSource() {
          // We don't polyfill very old IE, so bail
          if (!('EventSource' in window)) {
            return;
          }

          // Return current history with '?getcache=1'
          this.eventsource = new EventSource(`${this.url}?getcache=1`);
          this.eventsource.onmessage = (msg) => {
            const data = JSON.parse(msg.data);

            // Skip if new data older than existing
            if (this.data.updated > data.updated) {
              return;
            }
            this.data = data;
          };
        }
      </code></pre>
      <footer class="notes">
        <p class="note">The newsfeed component in Previous used Pusher and Web Sockets to get push updates. Next uses EventSource and Server Sent Events instead</p>
        <p class="note">EventSource is a built-in long-polling protocol, and is supported by all browsers except Microsoft's, but is easily polyfilled. It is unidirectional (push only), and very lightweight</p>
        <p class="note">Instead of paying millions to Pusher every year, we run instances of VG's SSEHub C++ app in Kubernetes</p>
        <p class="note">We had troubles earlier with network scaling with lots of users, but now have a setup that can support over 200,000 connections</p>
      </footer>
    </section>

    <section id="embed">
      <h1>#9 Core-Embed</h1>
      <footer class="notes">
        <p class="note">Next is also a 100% certified Core-Embed host application</p>
        <p class="note">Core-Embed is a contract for embedding trusted content into a web application</p>
        <p class="note"></p>
        <p class="note"></p>
        <p class="note"></p>
      </footer>
    </section>
  </main>
  <div class="clock"></div>
</body>
</html>
