<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Front-Office Next</title>
  <script type="module" src="index.js"></script>
  <link rel="stylesheet" type="text/css" href="index.scss">
  <link rel="stylesheet" type="text/css" href="assets/github.css">
</head>
<body>
  <main class="slides">
    <section id="title">
      <h1>KURATOR<br>Front-Office Next</h1>
      <footer class="notes">
        <p class="note">Hi!</p>
      </footer>
    </section>

    <section id="kurator">
      <figure>
        <img src="assets/back-office.jpg">
        <figcaption>Back-Office</figcaption>
      </figure>
      <figure>
        <img src="assets/front-office.jpg">
        <figcaption>Front-Office</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">We are very fond of cute code names here at NRK</p>
        <p class="note step">This is Kurator. It has two components: Back-Office is the application Journalists use to edit content, and Front-Office is the application that renders that content for the web</p>
      </footer>
    </section>

    <section id="front-office">
      <figure>
        <img src="assets/front-office-full.jpg">
        <span class="highlight highlight-house"><span>house</span></span>
        <span class="highlight highlight-floor"><span>floor</span></span>
        <span class="highlight highlight-room"><span>room</span></span>
        <span class="highlight highlight-newsfeed"><span>guestroom (newsfeed)</span></span>
      </figure>
      <footer class="notes">
        <p class="note">Front-Office is further divided into multiple parts</p>
        <p class="note step">This is a house</p>
        <p class="note step">This is a floor in that house</p>
        <p class="note step">This is a room in that floor</p>
        <p class="note step">And this is a guestroom called newsfeed</p>
      </footer>
    </section>

    <section id="front-office-next">
      <figure class="next">
        <img src="assets/front-office-full.jpg">
        <figcaption>Next</figcaption>
      </figure>
      <figure class="prev">
        <img src="assets/front-office-full.jpg">
        <figcaption>Previous</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">Last summer I asked Kristoffer, who was tech lead for Kurator at the time, if we could rewrite Front-Office. He said yes, as long as it looked exactly like the existing version</p>
        <p class="note step">Six months later, we have two versions of Front-Office: Previous and Next</p>
      </footer>
    </section>

    <section id="pixel">
      <figure>
        <div class="pixel prev"></div>
        <figcaption>Previous</figcaption>
      </figure>
      <figure>
        <div class="pixel next"></div>
        <figcaption>Next</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">If we compare a pixel from Previous and one from Next, they look the same</p>
        <p class="note step">But if a user gets that pixel sooner, are they really the same?</p>
        <p class="note step">And if a user wants a blue version of that pixel...</p>
        <p class="note step">...or purple...</p>
        <p class="note step">...or green...</p>
        <p class="note">...then they really aren't the same at all</p>
      </footer>
    </section>

    <section id="perf">
      <h1>Performance is a <em>feature</em></h1>
      <footer class="notes">
        <p class="note">This was the real motivation for the rewrite: improve render performance in order to be able to offer customized content</p>
        <p class="note">Performance is hard to observe directly, but it can enable other more visible features, and we wanted to open up for delivering personalised content on nrk.no</p>
      </footer>
    </section>

    <section id="simpler">
      <h1>"reducing complexity is the most important element of software design"</h1>
      <footer class="notes">
        <p class="note">My real motivation, however, was to design a system that was simpler</p>
      </footer>
    </section>

    <section id="book">
      <img src="assets/book.jpg">
      <ul>
        <li class="one">"the greatest limitation in writing software is our ability to understand the systems we are creating"</li>
        <li class="two">"if we want to make it easier to write software [...] we must find ways to make software simpler"</li>
        <li class="three">"developers should <strong>always</strong> be thinking about complexity"</li>
      </ul>
      <footer class="notes">
        <p class="note">This book by John Ousterhout is fantastic, and basically deals with high level techniques for reducing complexity in software systems</p>
        <p class="note step">quote</p>
        <p class="note step">quote</p>
        <p class="note step">quote</p>
      </footer>
    </section>

    <section id="steps">
      <h1>9 <em>shocking</em> steps to simplifying <br>your application (and your life)</h1>
      <footer class="notes">
        <p class="note"></p>
      </footer>
    </section>

    <section id="config">
      <h1>#1 Configuration</h1>
      <figure class="config-json">
        <pre class="code"><code class="json">
          {
            "api": {
              "cacheMaxSize": 1000,
              "maxAgeFeed": "1m",
              "maxAgeImmutable": "24h",
              "maxAgeMutable": "1s",
              "origin": "${__SUPPLIED_BY_ENV__}",
              "pathnames": {
                "blueprint": "/houses/${id}/ids",
                "house": "/houses/${itemId}/${id}",
                "feed": "/${type}/houses/${houseId}",
                "floor": "/floors/${itemId}/${id}",
                "room": "/rooms/${itemId}/${id}"
              },
              "retry": "${__SUPPLIED_BY_ENV__}",
              "secretKey": "${API_SECRET}",
              "timeout": "${__SUPPLIED_BY_ENV__}",
              "urls": "**generated at runtime**"
            }
          }
        </code></pre>
        <figcaption>/config.json</figcaption>
      </figure>
      <figure class="config-dir">
        <pre class="code"><code>
          **files here are added by runtime env**.txt
          **files here are loaded in sort order**.txt
          local.json
        </code></pre>
        <figcaption>/config</figcaption>
      </figure>
      <figure class="config-js">
        <pre class="code"><code class="js">
          import config from '@nrk/frontend-common/config.js';

          const houseEndpoint = config.get('api.urls.house');
          // => https://kurator-api-stage.nrk.no/houses/${itemId}/${id}
          const apartmentEndpoint = config.get('api.urls.apartment');
          // => Boom! Error: no config value found for "api.urls.apartment"
        </code></pre>
        <figcaption>/src/some.js</figcaption>
      </figure>
      <figure class="config-node-env">
        <pre class="code"><code class="json">
          {
            "NODE_ENV": {
              "test": {
                "api": {
                  "origin": "http://localhost:8080"
                }
              },
              "production": {
                "api": {
                  "origin": "https://kurator-api.nrk.no"
                }
              }
            }
          }
        </code></pre>
        <figcaption>/config/local.json</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">One of the most important goals of good design is for a system to be obvious, and one place where being obvious is important is application configuration</p>
        <p class="note step">Our new config setup describes all configuration options in one place (config.json), and is explicit about which values must be supplied by the runtime environment</p>
        <p class="note step">Environment values are loaded from the /config directory, which can be populated using Kubernetes ConfigMaps</p>
        <p class="note step">During runtime, any missing environment variables will throw and cause the application to crash, preventing rollout</p>
        <p class="note">Reading non-existant values will also throw an error. Obvious errors are simpler to fix than hidden ones</p>
        <p class="note step">Another benefit of being explicit is that the application has no concept of environment, only configuration, which is also much simpler</p>
      </footer>
    </section>

    <section id="dev-env">
      <h1>#2 Development Environment</h1>
      <figure class="video video-prev">
        <video loop src="assets/prev.mp4"></video>
        <figcaption>Previous</figcaption>
      </figure>
      <figure class="video video-next">
        <video loop src="assets/next.mp4"></video>
        <figcaption>Next</figcaption>
      </figure>
      <figure class="mock">
        <pre class="code"><code class="bash">
          âœ” loaded transpiler from scripts/transpile.js
          âœ” loaded 1 mock response from mock/bottom-menu.mock.json
          âœ” loaded 5 mock responses from mock/elglobo.mock.json
          âœ” loaded 4 mock responses from mock/floor-29-26.mock.json
          âœ” loaded 2 mock responses from mock/guestroom-133-7.mock.json
          âœ” loaded 127 mock responses from mock/house-12.mock.json
          âœ” loaded 136 mock responses from mock/house-2-900.mock.json
          âœ” loaded 45 mock responses from mock/house-5.mock.json
          âœ” loaded 144 mock responses from mock/house-uu.mock.json
          âœ” loaded 2 mock responses from mock/newsfeed.mock.json
          âœ” loaded 2 mock responses from mock/rss.mock.json
          âœ” loaded 1 mock response from mock/videoroom-289-288.mock.json

          ðŸ’¥ serving ./index-dev.js at http://localhost:3000
          ðŸ‘€ watching for changes...
        </code></pre>
        <figcaption>npm run dev:mock</figcaption>
      </figure>
      <figure class="test">
        <pre class="code"><code class="js">
          import application from '../index.js';
          import { expect } from 'chai';
          import { testServer } from 'dvlp';

          const api = await testServer({ autorespond: false, latency: 0, 8080 });

          api.mocks.add('http://localhost:8080/houses/2/ids', {
            error: true,
            body: {}
          });

          const app = await application();
          const res = await app.inject({
            method: 'GET',
            url: 'http://localhost:3000'
          });

          expect(res.statusCode).to.equal(500);
        </code></pre>
        <figcaption>/test/some-test.js</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">Probably the biggest differnce between Previous and Next is the development environment</p>
        <p class="note step">Previous used Nodemon to restart the application server, Babel to transpile server code, and Webpack to compile assets for the browser</p>
        <p class="note">This type of tooling chain is complex to set up, slow to restart after changes, and requires special server middleware to be used, forcing the application to be aware of it's environment</p>
        <p class="note step">Next uses dvlp to restart the application server, esm to enable es modules for server code, and no asset compiler (except Sass)</p>
        <p class="note">Most importantly, however, is that the application itself is totally unaware it's running in development. There is no difference between development and production code beyond configuration</p>
        <p class="note step">With dvlp we also get easy mocking during runtime...</p>
        <p class="note step">...and testing</p>
      </footer>
    </section>

    <section id="modules">
      <h1>#3 ES Modules</h1>
      <figure class="waterfall">
        <img src="assets/waterfall.jpg">
      </figure>
      <figure class="load">
        <pre class="code"><code class="html">
          &lt;head&gt;
            &lt;link rel=&quot;preload&quot; href=&quot;index.mjs&quot; as=&quot;script&quot;&gt;
            &lt;script&gt;
              window.cutsTheMustard = testDOMProp('visibilityState', document);
              if (window.Reflect == null) {
                loadScript('es6-polyfill.js', { async: false, defer: false });
              }
              if (!('customElements' in window)) {
                loadScript('dom-polyfill.js', { async: false, defer: false });
              }
            &lt;/script&gt;
            &lt;script&gt;
              loadScript('index.mjs', { async: false, defer: false, module: true });
            &lt;/script&gt;
            &lt;script nomodule&gt;
              loadScript(window.cutsTheMustard ? 'index.js' : 'index-legacy.js',
                { async: false, defer: false }
              );
            &lt;/script&gt;
          &lt;/head&gt;
        </code></pre>
      </figure>
      <footer class="notes">
        <p class="note">The most important development principle is that Next treats bundling as a production optimization, like minification</p>
        <p class="note step">During development, js files are loaded by the browser via standard es module import syntax</p>
        <p class="note">We write idiomatic JavaScript, and dvlp handles resolving bare imports behind the scenes</p>
        <p class="note">In production, server and client code is bundled with Rollup.js</p>
        <p class="note step">Client code is bundled twice to allow for serving different code to different browsers</p>
        <p class="note">This so-called differential bundling allows newer browsers to load untranspiled es6 code (async/await, classes, etc), and older browsers transpiled es5 code</p>
      </footer>
    </section>

    <section id="templates">
      <h1>#4 Tagged Template Literals</h1>
      <figure class="layout">
        <pre class="code"><code class="js">
          import Head from './head.js';
          import House from './house.js';
          import { html } from '@popeindustries/lit-html-server';

          /**
           * Layout template
           * @param {object} data
           * @param {RenderContext} context
           * @returns {TemplateResult}
           */
          function layout(data, context) {
            return html`
              &lt;!DOCTYPE html&gt;
              &lt;html lang=&quot;nb-NO&quot;&gt;
                ${Head(data, context)}
                &lt;body class=&quot;kur-house&quot;&gt;
                  ${House(data, context)}
                &lt;/body&gt;
              &lt;/html&gt;
            `;
          }
        </code></pre>
        <figcaption>/src/components/layout.js</figcaption>
      </figure>
      <figure class="component">
        <pre class="code"><code class="js">
          import Floor from './floor.js';
          import { getHouse } from '../data/api-agent.js';
          import { html } from '@popeindustries/lit-html-server';

          /**
           * House component
           * @param {object} data
           * @param {string} data.houseId
           * @param {RenderContext} context
           * @returns {Promise&lt;TemplateResult&gt;}
           */
          export default async function House(data, context) {
            const { floors } = await getHouse(data.houseId);

            return html`
              &lt;main&gt;
                ${floors.map((floor) =&gt; Floor(floor, context))}
              &lt;/main&gt;
            `;
          }
        </code></pre>
        <figcaption>/src/components/house.js</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">For rendering markup, Next uses lit-html's template literal syntax (instead of React)</p>
        <p class="note step">Template literals are a native JavaScript syntax for performing custom string interpolation</p>
        <p class="note">lit-html adds some sugar for handling attributes, and various helper functions called directives</p>
        <p class="note step">Note that the House component is an async function, and returns a Promise</p>
        <p class="note">The tag function can return anything, not just a string</p>
      </footer>
    </section>

    <section id="streaming">
      <h1>#5 Streaming</h1>
      <figure class="pipe">
        <pre class="code"><code class="js">
          import { createServer } from 'http';
          import { renderToStream } from '@popeindustries/lit-html-server';
          import template from './template.js';

          createServer((req, res) => {
            res.writeHead(200);
            renderToStream(template()).pipe(res);
          }).listen(3000);
        </code></pre>
      </figure>
      <figure class="server-timing">
        <img src="assets/server-timing.jpg">
        <figcaption>www.nrk.no/</figcaption>
      </figure>
      <figure class="error">
        <pre class="code"><code class="js">
          /**
           * Floor component
           * @param {object} data
           * @param {string} data.itemId
           * @param {string} data.id
           * @param {RenderContext} context
           * @returns {Promise&lt;TemplateResult&gt;}
           */
          export default async function Floor(data, context) {
            const floorData = await getFloor(data.itemId, data.id);

            if (floorData.error) {
              if (!context.isStreaming) {
                throw floorData.error;
              } else {
                // Fallback to empty floor
                return html`
                  &lt;section class=&quot;kur-floor&quot;&gt;&lt;/section&gt;
                `;
              }
            }
          }
        </code></pre>
        <figcaption>/src/components/floor.js</figcaption>
      </figure>
      <figure class="buffer">
        <pre class="code"><code class="js">
          import { handleError } from './error.js';
          import { renderToStream, renderToString }
            from '@popeindustries/lit-html-server';
          import template from './template.js';

          app.get('/', async (request, reply) => {
            let markup;
            try {
              if (request.isBot) {
                markup = await renderToString(template());
              } else {
                markup = renderToStream(template());
                markup.on('error', handleError);
              }
            } catch (err) {
              return handleError(err);
            }

            reply.type('text/html').code(200).send(markup);
          })
        </code></pre>
        <figcaption>/src/route.js</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">A streaming template renderer is capable of rendering the data structure returned by a tagged template literal as a Node.js ReadableStream, and push data to the response stream as async template data is resolved</p>
        <p class="note step">This enables us to "flush early, flush often", even before we begin fetching api data</p>
        <p class="note step">This streaming approach simplifies request handling by allowing us to get the response out the door as fast as possible</p>
        <p class="note step">The only weakness with this approach is that you won't be able to change the response status code if an error occurs during async rendering</p>
        <p class="note step">In cases where status codes are important (search engines, health checks, liveness probes, etc), we check the user-agent against a list of known non-human agents and buffer instead</p>
      </footer>
    </section>

    <section id="cache">
      <h1>#6 Caching</h1>
      <figure class="agent">
        <pre class="code"><code class="js">
          import { Cache } from '@nrk/frontend-common/cache.js';
          import config from '@nrk/frontend-common/config.js';
          import { staleWhileRevalidate }
            from '@nrk/frontend-common/cache-strategies.js';
          import { template } from '@nrk/frontend-common/string.js';

          const cache = new Cache();

          async function getFloor(itemId, id, context) {
            const url = template(config.get('api.urls.floor'), { itemId, id });
            try {
              return await staleWhileRevalidate(url, {
                defaultMaxAge: config.get('api.maxAgeImmutable'),
                requestOptions: {
                  retry: config.get('api.retry'),
                  timeout: config.get('api.timeout')
                }
              }).body;
            } catch (error) {
              return { id, itemId, error };
            }
          }
        </code></pre>
        <figcaption>/src/api-agent.js</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">Streaming in this way is possible because we have pushed data fetching responsibility down the render tree, and this is only possible due to our fetching and caching infrastructure</p>
        <p class="note step">Built around a port of the Browser's Cache api, data fetching is implemented via one of three cache strategies: network-first, stale-while-revalidate, or network-only</p>
        <p class="note">Includes retry, timeout, backoff, LRU, and request collapsing</p>
        <p class="note">Could be better: adaptive fetch control</p>
      </footer>
    </section>

    <section id="custom-elements">
      <h1>#7 Custom Elements</h1>
      <figure class="markup">
        <pre class="code"><code class="html">
          &lt;kur-newsfeed url=&quot;https://kurator-ssehub.nrk.no&quot;&gt;&lt;/kur-newsfeed&gt;
        </code></pre>
      </figure>
      <figure class="base-element">
        <pre class="code updatable"><code class="js">
          import UpdatableElement from '../../utils/updatable-element.js';

          class KurNewsfeed extends UpdatableElement {
            static get properties() {
              //...
            }
            initialise() {
              //...
            }
            render() {
              //...
            }
          }

          if (!window.customElements.get('kur-newsfeed')) {
            window.customElements.define('kur-newsfeed', KurNewsfeed);
          }
        </code></pre>
        <figcaption>/src/components/newsfeed-client.js</figcaption>
      </figure>
      <figure class="video">
        <video loop src="assets/newsfeed.mp4"></video>
      </figure>
      <footer class="notes">
        <p class="note"></p>
        <p class="note step">Next is largely a static page, but for the components that are interactive, we use Custom Elements to encapsulate client logic</p>
        <p class="note step">We created an element base class loosely based on lit-element</p>
        <p class="note">The most importand feature of Custom Elements for Next is that components are self registering, and code can run as soon as possible before markup is rendered</p>
        <p class="note step"></p>
      </footer>
    </section>

    <section id="sse">
      <h1>#8 EventSource</h1>
      <img src="assets/newsfeed.jpg">
      <figure class="es">
        <pre class="code"><code class="js">
          initEventSource() {
            // We don't polyfill very old IE, so bail
            if (!('EventSource' in window)) {
              return;
            }

            // Return current history with '?getcache=1'
            this.eventsource = new EventSource(`${this.url}?getcache=1`);
            this.eventsource.onmessage = (msg) => {
              const data = JSON.parse(msg.data);

              // Skip if new data older than existing
              if (this.data.updated > data.updated) {
                return;
              }
              this.data = data;
            };
          }
        </code></pre>
        <figcaption>/src/components/newsfeed-client.js</figcaption>
      </figure>
      <footer class="notes">
        <p class="note"></p>
        <p class="note step">The newsfeed component in Previous used Pusher and Web Sockets to get push updates. Next uses EventSource and Server Sent Events instead</p>
        <p class="note step">EventSource is a built-in long-polling protocol, and is supported by all browsers except Microsoft's, but is easily polyfilled. It is unidirectional (push only), and very lightweight</p>
        <p class="note">Instead of paying millions to Pusher every year, we run instances of VG's SSEHub C++ app in Kubernetes</p>
        <p class="note">We had troubles earlier with network scaling with lots of users, but now have a setup that can support over 200,000 connections</p>
      </footer>
    </section>

    <section id="embed">
      <h1>#9 Core-Embed</h1>
      <figure class="manifest">
        <pre class="code"><code class="json">
          {
            "name": "nrk-fancy-ui-widget-v1",
            "version": 1,
            "description": "A fancy ui widget",
            "host": "https://fancy.nrk.no/fancy-ui-widget/v1",
            "package": "@nrk/fancy-ui-widget",
            "config": {
              "type": "object",
              "required": ["title"],
              "properties": {
                "color": {
                  "type": "string",
                  "default": "0x0000ff"
                },
                "title": {
                  "type": "string"
                },
                "expanded": {
                  "type": "boolean",
                  "default": true
                }
              }
            },
            "coreEmbedVersion": 1
          }
        </code></pre>
        <figcaption>https://fancy.nrk.no/fancy-ui-widget/v1/embed.json</figcaption>
      </figure>
      <figure class="embedroom">
        <pre class="code"><code class="js">
          export default async function EmbedRoom({ manifest }, context) {
            let basePath, content;

            try {
              const { render } = await dynamicImport(manifest.package);
              content = render(manifest.config);
              basePath = `/node_modules/${manifest.package}`;
            } catch (err) {
              // Fallback to hosted version
              content = await postEmbedContent(manifest.host, manifest.config, context);
              basePath = host;
            }

            return html`
              &lt;div class=&quot;kur-room embed&quot;&gt;
                ${renderDependencies('css', basePath, content.dependencies, context)}
                ${unsafeHTML(content.markup)}
                ${renderDependencies('js', basePath, content.dependencies, context)}
              &lt;/div&gt;
            `;
          }
        </code></pre>
        <figcaption>/src/components/embed-room.js</figcaption>
      </figure>
      <figure class="markup">
        <pre class="code"><code class="html">
          &lt;div class=&quot;kur-room embed&quot;&gt;
            &lt;link
              rel=&quot;stylesheet&quot;
              crossorigin=&quot;anonymous&quot;
              href=&quot;https://fancy.nrk.no/fancy-ui-widget/v1/render/assets/index.css&quot;
            /&gt;
            &lt;!-- skipping https://static.nrk.no/core-fonts/major/2/core-fonts.css --&gt;
            &lt;nrk-fancy-ui-widget-v1 color=&quot;0x0000ff&quot; expanded&gt;
              &lt;h2&gt;Very Fancy Tittel&lt;/h2&gt;
            &lt;/nrk-fancy-ui-widget-v1&gt;
            &lt;script&gt;
              window.loadScript(
                &apos;https://fancy.nrk.no/fancy-ui-widget/v1/render/assets/index.js&apos;,
                { async: false, defer: false, crossorigin: &apos;anonymous&apos; }
              );
            &lt;/script&gt;
          &lt;/div&gt;
        </code></pre>
      </figure>
      <figure class="backoffice">
        <img src="assets/embed-bo.png">
        <figcaption>Back Office</figcaption>
      </figure>
      <footer class="notes">
        <p class="note">Next is also a 100% certified Core-Embed host application</p>
        <p class="note step">Core-Embed is a contract for embedding trusted content into a web application</p>
        <p class="note step"></p>
        <p class="note step"></p>
        <p class="note step"></p>
      </footer>
    </section>

    <section id="done">
      <h1>Done!</h1>
      <ul>
        <li class="one">Make configuration explicit and obvious</li>
        <li class="two">Use modules the right way, <br>and only bundle for production</li>
        <li class="three">Stream your responses</li>
        <li class="four">Zero-tolerance for complexity!</li>
      </ul>
      <footer class="notes">
        <p class="note"></p>
        <p class="note step"></p>
        <p class="note step"></p>
        <p class="note step"></p>
        <p class="note step"></p>
      </footer>
    </section>
  </main>
  <div class="clock"></div>
</body>
</html>
